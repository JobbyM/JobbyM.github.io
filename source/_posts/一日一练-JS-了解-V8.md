---
title: 一日一练-JS 了解 V8
date: 2021-07-12 15:47:57
tags:
  - 技术
  - 一日一练
  - JS
  - V8
  - 转载
categories: 技术
---


本文转载自[读李老课程引发的思考之JS设计思想篇](https://mp.weixin.qq.com/s?__biz=MzU5NDM5MDg1Mw==&mid=2247487517&idx=2&sn=f5fd6cef41b856ea4f4aca2de915760c&chksm=fe00aa37c97723217acee08b2e20dea2b53ed44b6dc8910aec57b4e9c1c71294847ee681fa1a&token=828996357&lang=zh_CN#rd)，有部分删节，看原文请到原地址。

## V8 是如何执行一段 JavaScript 代码的？
### V8 是怎么执行 JavaScript 代码的呢
其主要核⼼流程分为编译和执⾏两步。⾸先需要将 JavaScript 代码转换为低级中间代码或者机器能够理解的机器代码，然后再执⾏转换后的代码并输出执⾏结果。
{% asset_img 1.webp %}

<!--more-->

### 什么是解释执行
解释执⾏，需要先将输⼊的源代码通过解析器编译成中间代码，之后直接使⽤解释器解释执⾏中间代码，然后直接输出结果。具体流程如下图所⽰：
{% asset_img 2.webp %}

### 什么是编译执行
编译执⾏。采⽤这种⽅式时，也需要先将源代码转换为中间代码，然后我们的编译器再将中间代码编译成机器代码。通常编译成的机器代码是以⼆进制⽂件形式存储的，需要执⾏这段程序的时候直接执⾏⼆进制⽂件就可以了。还可以使⽤虚拟机将编译后的机器代码保存在内存中，然后直接执⾏内存中的⼆进制代码。
{% asset_img 3.png %}

### V8 作为 JavaScript 的虚拟机的一种，是解释执行还是编译执行？
实际上，V8 并没有采⽤某种单⼀的技术，⽽是混合编译执⾏和解释执⾏这两种⼿段，我们把这种混合使⽤ 编译器和解释器的技术称为 JIT（Just?In?Time）技术。这是⼀种权衡策略，因为这两种⽅法都各⾃有⾃的优缺点，解释执⾏的启动速度快，但是执⾏时的速度慢， ⽽编译执⾏的启动速度慢，但是执⾏时的速度快。你可以参看下⾯完整的 V8 执⾏ JavaScript 的流程图：
{% asset_img 4.png %}

相信你注意到了，我们在解释器附近画了个监控机器⼈，这是⼀个监控解释器执⾏状态的模块，在解释执⾏字节码的过程中，如果发现了某⼀段代码会被重复多次执⾏，那么监控机器⼈就会将这段代码标记为热点代 码。当某段代码被标记为热点代码后，V8就会将这段字节码丢给优化编译器，优化编译器会在后台将字节码编 译为⼆进制代码，然后再对编译后的⼆进制代码执⾏优化操作，优化后的⼆进制机器代码的执⾏效率会得到⼤幅提升。如果下⾯再执⾏到这段代码时，那么 V8 会优先选择优化之后的⼆进制代码，这样代码的执⾏速度就会⼤幅提升。

理解了这⼀点，我们就可以来深⼊分析 V8 执⾏⼀段 JavaScript 代码所经历的主要流程了，这包括了：

* 初始化基础环境；
* 解析源代码生成 AST 和作用域;
* 根据 AST 和作用域生成字节码；
* 解释执行字节码；
* 监听热点代码；
* 优化热点代码为二进制的机器码；
* 反优化⽣成的⼆进制机器代码

## 函数即对象，函数的特点
### JS 是一门面向对象的语言吗？
不是的，js 是基于对象设计的，但不是面向对象的语言

### JS 与面向对象语言在继承上有什么区别？
⾯向对象语⾔是由语⾔本⾝对继承做了充分的⽀持，并提供了⼤量的关键字，如 public、protected、friend、interface 等，众多的关键字使得⾯向对象语⾔的继承变得异常繁琐和复杂，「**⽽ JavaScript 中实现继承的⽅式却⾮常简单清爽， 只是在对象中添加了⼀个称为原型的属性，把继承的对象通过原型链接起来，就实现了继承，我们把这种继承⽅式称为基于原型链继承**」

### V8 内部是怎么实现函数可调用特性的呢？
在V8内部，我们会为函数对象添加了两个隐藏属性，具体属性如下图所⽰：
{% asset_img 5.png %}

也就是说，函数除了可以拥有常⽤类型的属性值之外，还拥有两个隐藏属性，分别是 name 属性和 code 属性。隐藏 name 属性的值就是函数名称，如果某个函数没有设置函数名，如下⾯这段函数：
```js
(function (){
    var test = 1
    console.log(test)
})()
```

该函数对象的默认的 name 属性值就是 anonymous，表⽰该函数对象没有被设置名称。另外⼀个隐藏属性是 code 属性，其值表⽰函数代码，以字符串的形式存储在内存中。当执⾏到⼀个函数调⽤语句时，V8 便会从函数对象中取出 code 属性值，也就是函数代码，然后再解释执⾏这段函数代码

### function 在 JavaScript 中是一等公民，何为一等公民
* 一等公民可以作为函数参数，可以作为函数返回值，也可以赋值给变量
* **如果某个编程语言的函数，可以和这个语言的数据类型做一样的事情，我们就把这个语言中的函数成为一等公民**。例如，字符串在几乎所有编程语言中都是一等公民，字符串可以作为函数参数，字符串可以作为函数返回值，字符串也可以赋值给变量。对于各种编程语言来说，函数就不一定是一等公民了，比如 Java 8 之前的版本。
* 对于 JavaScript 来说，函数可以赋值给变量，也可以作为函数参数，还可以作为函数返回值，因此 **JavaScript 中函数是一等公民**。

### 什么是闭包？
将外部变量和和函数绑定起来的技术称为闭包
```js
function foo() {
    var number = 1
    function bar() {
        number ++
        console.log(number)
    }
    return bar
}
var mybar = foo()
mybar()
```

观察上段代码可以看到，我们在 foo 函数中定义了⼀个新的 bar 函数，并且 bar 函数引⽤了 foo 函数中的变量 number，当调⽤ foo 函数的时候，它会返回 bar 函数。

### 闭包的三个基础特性
* JavaScript 语言允许在函数内部定义新函数
* 可以在内部函数访问父函数中定义的变量
* 因为 JavaScript 中的函数是一等公民，所以函数可以作为另外一个函数的返回值。

## 快属性和满属性：V8 采用了哪些策略提升了对象的访问速度？
### 什么是对象中的常规属性和排序属性
```js
function Foo() {
    this[100] = 'test-100'
    this[1] = 'test-1'
    this["B"] = 'bar-B'
    this[50] = 'test-50'
    this[9] = 'test-9'
    this[8] = 'test-8'
    this[3] = 'test-3'
    this[5] = 'test-5'
    this["A"] = 'bar-A'
    this["C"] = 'bar-C'
}
var bar = new Foo()
for (key in bar) {
    console.log(`index:${key} value:${bar[key]}`)
}
```

在上⾯这段代码中，我们利⽤构造函数 Foo 创建了⼀个 bar 对象，在构造函数中，我们给 bar 对象设置了很多属性，包括了数字属性和字符串属性，然后我们枚举出来了 bar 对象中所有的属性，并将其⼀⼀打印出来， 下⾯就是执⾏这段代码所打印出来的结果
```bash
index:1 value:test-1
index:3 value:test-3
index:5 value:test-5
index:8 value:test-8
index:9 value:test-9
index:50 value:test-50
index:100 value:test-100
index:B value:bar-B
index:A value:bar-A
index:C value:bar-C
```

观察这段打印出来的数据，我们发现打印出来的属性顺序并不是我们设置的顺序，我们设置属性的时候是乱序设置的，⽐如开始先设置 100，然后有设置了 1，但是输出的内容却⾮常规律，总的来说体现在以下两 点：

* 设置的数字属性被最先打印出来了，并且按照数字⼤⼩的顺序打印的；

* 设置的字符串属性依然是按照之前的设置顺序打印的，⽐如我们是按照 B、A、C 的顺序设置的，打印出来，依然是这个顺序。

之所以出现这样的结果，是因为在 [ECMAScript 规范](http://www.ecma-international.org/ecma-262/11.0/index.html)中定义了 **「数字属性应该按照索引值⼤⼩升序排列，字符串属性根据创建时的顺序升序排列。」**在这⾥我们把对象中的数字属性称为 **「排序属性」**，在V8中被称为 elements；字符串属性就被称为 **「常规属性」**， 在 V8 中被称为 properties。在 V8 内部，为了有效地提升存储和访问这两种属性的性能，分别使⽤了两个**线性数据**结构来分别保存排序属性和常规属性，具体结构如下图所⽰：
{% asset_img 6.png %}

在 elements 对象中，会按照顺序存放排序属性，properties 属性则指向了 properties 对象，在 properties 对象中，会按照创建时的顺序保存了常规属性。

### 什么是对象内属性
将不同的属性分别保存到 elements 属性和 properties 属性中，⽆疑简化了程序的复杂度，但是在查找元素时，却多了⼀步操作，⽐如执⾏ `bar.B` 这个语句来查找 B 的属性值，那么在 V8 会先查找出 properties 属性所指向的对象 properties，然后再在 properties 对象中查找 B 属性，这种⽅式在查找过程中增加了⼀步操作， 因此会影响到元素的查找效率。基于这个原因，V8 采取了⼀个权衡的策略以加快查找属性的效率，这个策略是将部分常规属性直接存储到 对象本⾝，我们把这称为 「**对象内属性(in-object?properties)**」。对象在内存中的展现形式你可以参看下图：

{% asset_img 7.png %}

采⽤对象内属性之后，常规属性就被保存到 bar 对象本⾝了，这样当再次使⽤ `bar.B` 来查找B的属性值时， V8 就可以直接从 bar 对象本⾝去获取该值就可以了，这种⽅式减少查找属性值的步骤，增加了查找效率。不过对象内属性的数量是固定的，默认是 10 个，如果添加的属性超出了对象分配的空间，则它们将被保存在常规属性存储中。虽然属性存储多了⼀层间接层，但可以⾃由地扩容。

### 什么是快属性和慢属性
通常，我们将保存在线性数据结构中的属性称之为“快属性”，因为线性数据结构中只需要通过索引即可以访问到属性，虽然访问线性结构的速度快，但是如果从线性结构中添加或者删除⼤量的属性时，则执⾏效率 会⾮常低，这主要因为会产⽣⼤量时间和内存开销。因此，如果⼀个对象的属性过多时，V8 为就会采取另外⼀种存储策略，那就是“慢属性”策略，但慢属性 的对象内部会有独⽴的⾮线性数据结构(词典)作为属性存储容器。所有的属性元信息不再是线性存储的，⽽ 是直接保存在属性字典中。

{% asset_img 8.png %}

## 堆空间和栈空间
### 栈空间
* 现代语言都是基于函数的，每个函数在执行过程中，都有自己的生命周期和作用域，当函数执行结束时，其作用域也会被销毁，因此，我们会使用这种数据结构来管理函数的调用过程，我们也把管理函数调用过程的栈结构称之为**调用栈**。
* **栈空间**主要是用来管理 JavaScript 函数调用的，栈是内存中连续的一块空间，同时栈结构是“先进后出”的策略。在函数调用过程中，涉及到上下文相关的内容都会存放在栈上，比如原生类型、引用到的对象的地址、函数的执行状态、this 值等都会存在在栈上。当一个函数执行结束，那么该函数的执行上下文便会被销毁掉。
* **栈空间的最大的特点是空间连续**，所以在栈中每个元素的地址都是固定的，因此栈空间的查找效率非常高，但是通常在内存中，很难分配到一块很大的连续空间，因此，V8 对栈空间的大小做了限制，如果函数调用层过深，那么 V8 就有可能抛出栈溢出的错误。
* 栈的优势和缺点
    * 栈的结构非常适合函数调用过程。
    * **在栈上分配资源和销毁资源的速度非常快**，这主要归结于栈空间是连续的，分配空间和销毁空间只需要移动下指针就可以了。
    * 虽然操作速度非常快，但是栈也是有缺点的，其中最大的缺点也是它的优点所造成的，那就是**栈是连续的**，所以要想在内存中分配一块连续的大空间是非常难的，因此**栈空间是有限的**
        ```js
        // 栈溢出
        function factorial(n) {
            if (n === 1) {
                return 1
            }
            return n * factorial(n - 1)
        }
        console.log(factorial(50000))

        ```

### 堆空间
* **堆空间**是一种树形的存储结构，**用来存储对象类型的离散的数据**，JavaScript 中除了原生类型的数据，其他的都是对象类型，诸如函数、数组，在浏览器中还有 window 对象、document 对象等，这些都是存在堆空间的。
* 宿主在启动 V8 的过程中，会同时创建堆空间和栈空间，再继续往下执行，产生的新数据都会存放在这两个空间中。

### 继承
**继承就是一个对象可以访问另外一个对象中的属性和方法，在 JavaScript 中，我们通过原型和原型链的方式来实现了继承特性。**

JavaScript 的每个对象都包含了一个隐藏属性 `__proto__` ，我们就把该隐藏属性 `__proto__` 称之为该对象的原型 (prototype)，`__proto__` 指向了内存中的另外一个对象，我们就把 `__proto__` 指向的对象称为该对象的原型对象，那么该对象就可以直接访问其原型对象的方法或者属性。

  JavaScript 中的继承非常简洁，就是每个对象都有一个原型属性，该属性指向了原型对象，查找属性的时候，JavaScript 虚拟机会沿着原型一层一层向上查找，直至找到正确的属性。

#### 隐藏属性 `__proto__`
```js
var animal = {
    type: 'Default',
    color: 'Default',
    getInfo: function () {
        return `Type is: ${this.type}, color is: ${this.color}`
    }
}
var dog = {
    type: 'Dog',
    color: 'Black',
}
```

利用 `__proto__` 实现继承
```js
dog.__proto__ = animal  // Object.setPrototypeOf(dog, animal)
dog.getInfo()
```

通常隐藏属性是不能使用 JavaScript 来直接与之交互的。虽然现代浏览器都开了一个口子，让 JavaScript 可以访问隐藏属性 `__proto__`，但是在实际项目中，我们不应该直接通过 `__proto__` 来访问或者修改该属性，其主要原因有两个：

* 首先，这是隐藏属性，并不是标准定义的;
* 其次，使用该属性会造成严重的性能问题。因为 JavaScript 通过隐藏类优化了很多原有的对象结构，所以通过直接修改 `__proto__` 会直接破坏现有已经优化的结构，触发 V8 重构该对象的隐藏类！

### 构造函数是怎么创建对象的？
在 JavaScript 中，使用 new 加上构造函数的这种组合来创建对象和实现对象的继承。不过使用这种方式隐含的语义过于隐晦。其实是 JavaScript 为了吸引 Java 程序员、在语法层面去蹭 Java 热点，所以就被硬生生地强制加入了非常不协调的关键字 new。
```js
function DogFactory(type, color) {
  this.type = type;
  this.color = color;
}
var dog = new DogFactory('Dog', 'Black');
```

其实当 V8 执行上面这段代码时，V8 在背后悄悄地做了以下几件事情：
```js
var dog = {}
dog.__proto__ = DogFactory.prototype
DogFactory.call(dog, 'Dog', 'Black')
```


## 函数表达式：涉及大量概念，函数表达式到底该怎么学？
### 函数声明与函数表达式的差异
{% asset_img 9.png %}

同样是在定义的函数之前调⽤函数，第⼀段代码就可以正确执⾏，⽽第⼆段代码却报错，这是为什么呢？其主要原因是这两种定义函数的⽅式具有不同语义，不同的语义触发了不同的⾏为。

因为语义不同，所以我们给这两种定义函数的⽅式使⽤了不同的名称，第⼀种称之为 「**函数声明**」，第⼆种称之 为「**函数表达式**」


### V8 是怎么处理函数声明的？
V8 在执⾏ JavaScript 的过程中，会先对其进⾏编译，然后再执⾏，⽐如下⾯这段代码：
```js
var x = 5
function foo() {
    console.log('Foo')
}
```

V8 执⾏这段代码的流程⼤致如下图所⽰：
{% asset_img 10.webp %}

在编译阶段，如果解析到函数声明，那么 V8 会将这个函数声明转换为内存中的函数对象（「**函数名放在栈，函数体放在堆**」），并将其放到作⽤域中。同样，如果解析到了某个变量声明，也会将其放到作⽤域中，但是会将其值设置为 undefined，表⽰ 该变量还未被使⽤。

然后在 V8 执⾏阶段，如果使⽤了某个变量，或者调⽤了某个函数，那么 V8 便会去作⽤域查找相关内容。

### 什么是变量提升？
因为在执⾏之前，这些变量都被提升到作⽤域中了，所以在执⾏阶段，V8 当然就能获取到所有的定义变量了。我们把这种在编译阶段，将所有的变量提升到作⽤域的过程称为「**变量提升**」

### 表达式和语句的区别是什么
简单地理解，表达式就是表⽰值的式⼦，⽽语句是操作值的式⼦。

⽐如：
```js
x = 5
```


就是表达式，因为执⾏这段代码，它会返回⼀个值。同样，`6 === 5` 也是⼀个表达式，因为它会返回 `false`。

⽽语句则不同了，⽐如你定义了⼀个变量：
```js
var x;
```

这就是⼀个语句，执⾏该语句时，V8 并不会返回任何值给你。同样，当我声明了⼀个函数时，这个函数声明也是⼀个语句，⽐如下⾯这段函数声明：
```js
function foo() {
    return 1
}
```

当执⾏到这段代码时，V8 并没有返回任何的值，它只是解析 foo 函数，并将函数对象存储到内存中。

「**这么一来就说明了，语句的执行是编译阶段，把变量放到作用域，导致变量提升，表达式的执行是在执行阶段，导致作用域中的变量的值的改变。**」

### 函数声明是表达式还是语句？
```js
function foo() {
    console.log('Foo')
}
```

执⾏上⾯这段代码，它并没有输出任何内容，所以可以肯定，函数声明并不是⼀个表达式，⽽是⼀个语句。

总的来说，在 V8 解析 JavaScript 源码的过程中，如果遇到普通的变量声明，那么便会将其提升到作⽤域中， 并给该变量赋值为 undefined，如果遇到的是函数声明，那么 V8 会在内存中为声明⽣成函数对象，并将该对象提升到作⽤域中。
{% asset_img 11.png %}

我觉得最有意思的是下面这道题

### 为什么立即调用的函数表达式（IIFE）可以拥有私有作用域
JavaScript 中有⼀个圆括号运算符，圆括号⾥⾯可以放⼀个表达式，⽐如下⾯的代码：
```js
(a = 3)
```

括号⾥⾯是⼀个表达式，整个语句也是⼀个表达式，最终输出 3。如果在⼩括号⾥⾯放上⼀段函数的定义，如下所⽰：
```js
(function(){
    //Statements
})
```

因为⼩括号之间存放的必须是表达式，所以如果在⼩括号⾥⾯定义⼀个函数，那么 V8 就会把这个函数看成是**函数表达式**，执⾏时它会返回⼀个函数对象

存放在括号⾥⾯的函数便是⼀个函数表达式，它会返回⼀个函数对象，如果我直接在表达式后⾯加上调⽤的 括号，这就称**⽴即调⽤函数表达式（IIFE）**，⽐如下⾯代码：
```js
(function(){
    //Statements
})()
```

因为函数⽴即表达式也是⼀个表达式，所以 V8 在编译阶段，并不会为该表达式创建函数对象。**这样的⼀个好处就是不会污染环境，函数和函数内部的变量都不会被其他部分的代码访问到**。

### 变量 a 的值什么
```js
var a = (function(){
    return 1
})()
```

因为函数⽴即表达式是⽴即执⾏的，所以将⼀个函数⽴即表达式赋给⼀个变量时，不是存储 `IIFE` 本 ⾝，⽽是存储 `IIFE` 执⾏后返回的结果，所以 `a=1` 。

## 作用域链：V8 是如何查找变量的？
### 全局作用域和函数作用域
全局作⽤域和函数作⽤域类似，也是存放变量和函数的地⽅，但是它们还是有点不⼀样：「**全局作⽤域是在 V8 启动过程中就创建了，且⼀直保存在内存中不会被销毁的，直⾄ V8 退出。 ⽽函数作⽤域是在执⾏该函数时创建的，当函数执⾏结束之后，函数作⽤域就随之被销毁掉了。**」

### 什么是词法作用域
因为 JavaScript 是基于词法作⽤域的，词法作⽤域就是指，查找作⽤域的顺序是按照函数定义时的位置来决 定的。bar 和 foo 函数的外部代码都是全局代码，所以⽆论你是在 bar 函数中查找变量，还是在 foo 函数中查找变量，其查找顺序都是按照`当前函数作⽤域‒>全局作⽤域`这个路径来的。

由于我们代码中的 foo 函数和 bar 函数都是在全局下⾯定义的，所以在 foo 函数中使⽤了 type，最终打印出来的值就是全局作⽤域中的 type。
{% asset_img 12.png %}

### 什么是动态作用域和静态作用域
因为词法作⽤域是根据函数在代码中的位置来确定的，作⽤域是在声明函数时就确定好的了，所以我们也将**词法作⽤域**称为**静态作⽤域**。和静态作⽤域相对的是动态作⽤域，动态作⽤域并不关⼼函数和作⽤域是如何声明以及在何处声明的，只关⼼**它们从何处调⽤**。换句话说，作⽤域链是基于调⽤栈的，⽽不是基于函数定义的位置的。

## 类型转换：V8 是怎么实现1 - “2” 的？
### V8 是怎么实现1 - “2” 的？
V8 会提供了⼀个 ToPrimitve ⽅法，其作⽤是将 a 和 b 转换为原⽣数据类型，其转换流程如下：

* 先检测该对象中是否存在 valueOf ⽅法，如果有并返回了原始类型，那么就使⽤该值进⾏强制类型转换；
* 如果 valueOf 没有返回原始类型，那么就使⽤ toString ⽅法的返回值；
* 如果 valueOf 和 toString 两个⽅法都不返回基本类型值，便会触发⼀个 TypeError 的错误。
将对象转换为原⽣类型的流程图如下所⽰：

{% asset_img 13.png %}

当V8执⾏1+“2”时，因为这是两个原始值相加，原始值相加的时候，如果其中⼀项是字符串，那么V8会默 认将另外⼀个值也转换为字符串，相当于执⾏了下⾯的操作：
```js
Number(1).toString() + "2"
```

「**注意**」：上面 valueOf 和 toString 的调用顺序仅适用于运算。其他情况可以参考[8. {} 和 [] 的 valueOf 和 toString 的结果是什么？](https://mp.weixin.qq.com/s?__biz=MzU5NDM5MDg1Mw==&mid=2247487054&idx=1&sn=0b11f13277367b4ea3d9c22583e4ab86&chksm=fe00b464c9773d728166fe748356751535b1ecd39f0a0f7707bd6e7d6f4f22aaa738cd0559b7&token=1504899798&lang=zh_CN&scene=21#wechat_redirect).


## 异步编程与消息队列
### V8 是如何执行回调函数的
回调函数有两种类型：同步回调和异步回调，同步回调函数是在执行函数内部被执行的，而异步回调函数是在执行函数外部被执行的。
 
通用 UI 线程宏观架构：
{% asset_img 14.jpg %}

UI 线程提供一个消息队列，并将待执行的事件添加到消息队列中，然后 UI 线程会不断循环地从消息队列中取出事件、执行事件。关于异步回调，这里也有两种不同的类型，其典型代表是 setTimeout 和 XMLHttpRequest：

* setTimeout 的执行流程其实是比较简单的，在 setTimeout 函数内部封装回调消息，并将回调消息添加进消息队列，然后主线程从消息队列中取出回调事件，并执行回调函数。
* XMLHttpRequest 稍微复杂一点，因为下载过程需要放到单独的一个线程中去执行，所以执行 XMLHttpRequest.send 的时候，宿主会将实际请求转发给网络线程，然后 send 函数退出，主线程继续执行下面的任务。网络线程在执行下载的过程中，会将一些中间信息和回调函数封装成新的消息，并将其添加进消息队列中，然后主线程从消息队列中取出回调事件，并执行回调函数。

### 宏任务和微任务
* 调用栈：调用栈是一种数据结构，用来管理在主线程上执行的函数的调用关系。主线程在执行任务的过程中，如果函数的调用层次过深，可能造成栈溢出的错误，我们可以使用 **setTimeout 来解决栈溢出的问题**。setTimeout 的本质是将同步函数调用改成异步函数调用，这里的异步调用是将回调函数封装成宏任务，并将其添加进消息队列中，然后主线程再按照一定规则循环地从消息队列中读取下一个宏任务。

* 宏任务：就是指消息队列中的等待被主线程执行的事件。每个宏任务在执行时，V8 都会重新创建栈，然后随着宏任务中函数调用，栈也随之变化，最终，当该宏任务执行结束时，整个栈又会被清空，接着主线程继续执行下一个宏任务。

* 微任务：你可以把微任务看成是一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前。

* **JavaScript 中之所以要引入微任务，主要是由于主线程执行消息队列中宏任务的时间颗粒度太粗了，无法胜任一些对精度和实时性要求较高的场景，微任务可以在实时性和效率之间做一个有效的权衡**。另外使用微任务，可以改变我们现在的异步编程模型，使得我们可以使用同步形式的代码来编写异步调用。

* 微任务是基于消息队列、事件循环、UI 主线程还有堆栈而来的，然后基于微任务，又可以延伸出协程、Promise、Generator、await/async 等现代前端经常使用的一些技术。

{% asset_img 15.jpg %}

```js
// 不会使浏览器卡死
function foo() {
    setTimeout(foo, 0)
}
foo()
```

{% asset_img 16.jpg %}

微任务：
```js
// 浏览器 console 控制台 可使浏览器卡死（无法响应鼠标事件等）
function foo() {
    return Promise.resolve().then(foo)
}
foo()
```

* 如果当前的任务中产生了一个微任务，通过 Promise.resolve() 或者 Promise.reject() 都会触发微任务，触发的微任务不会在当前的函数中被执行，所以**执行微任务时，不会导致栈的无限扩张**；

* 和异步调用不同，微任务依然会在当前任务执行结束之前被执行，这也就意味着**在当前微任务执行结束之前，消息队列中的其他任务是不可能被执行的**。因此在函数内部触发的微任务，一定比在函数内部触发的宏任务要优先执行。

* 微任务依然是在当前的任务中执行的，所以如果在微任务中循环触发新的微任务，那么将导致消息队列中的其他任务没有机会被执行。

## 前端异步编程史
{% asset_img 17.jpg %}

* Callback 模式的异步编程模型需要实现大量的回调函数，大量的回调函数会打乱代码的正常逻辑，使得代码变得不线性、不易阅读，这就是我们所说的**回调地狱问题**。

* Promise 能很好地解决回调地狱的问题，我们可以按照线性的思路来编写代码，这个过程是线性的，非常符合人的直觉。

* 但是这种方式**充满了 Promise 的 then() 方法**，如果处理流程比较复杂的话，那么整段代码将**充斥着大量的 then，语义化不明显，代码不能很好地表示执行流程**。我们想要通过线性的方式来编写异步代码，要实现这个理想，**最关键的是要能实现函数暂停和恢复执行的功能**。而**生成器**就可以实现函数暂停和恢复，我们可以在生成器中使用同步代码的逻辑来异步代码 (实现该逻辑的核心是协程)。

* 但是在生成器之外，我们还需要一个**触发器**来驱动生成器的执行。前端的最终方案就是 async/await，async 是一个可以暂停和恢复执行的函数，在 async 函数内部使用 await 来暂停 async 函数的执行，await 等待的是一个 Promise 对象，如果 Promise 的状态变成 resolve 或者 reject，那么 async 函数会恢复执行。因此，使用 async/await 可以实现以同步的方式编写异步代码这一目标。和生成器函数一样，使用了 async 声明的函数在执行时，也是一个单独的协程，我们可以使用 await 来暂停该协程，由于 await 等待的是一个 Promise 对象，我们可以 resolve 来恢复该协程。

### 协程
* **协程**是一种比线程更加轻量级的存在。你可以把协程看成是跑在线程上的任务，一个线程上可以存在多个协程，但是在线程上同时只能执行一个协程。比如，当前执行的是 A 协程，要启动 B 协程，那么 A 协程就需要将主线程的控制权交给 B 协程，这就体现在 A 协程暂停执行，B 协程恢复执行；同样，也可以从 B 协程中启动 A 协程。通常，如果从 A 协程启动 B 协程，我们就把 A 协程称为 B 协程的父协程。

* **正如一个进程可以拥有多个线程一样，一个线程也可以拥有多个协程**。每一时刻，该线程只能执行其中某一个协程。最重要的是，**协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行）**。这样带来的好处就是性能得到了很大的提升，不会像线程切换那样消耗资源。

[co 函数库的含义和用法](http://www.ruanyifeng.com/blog/2015/05/co.html)

## 参考文档
1.[segmentfault 浏览器是如何工作的：Chrome V8 让你更懂JavaScript](https://segmentfault.com/a/1190000037435824)
